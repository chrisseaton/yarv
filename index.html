<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="initial-scale=1, maximum-scale=5">
    <title>YARV</title>
    <link rel="stylesheet" type="text/css" href="style.css">
  </head>
  <body>
    <main>
      <aside>
        <nav>
          <a href="#branchunless">branchunless</a>
<a href="#concatarray">concatarray</a>
<a href="#definemethod">definemethod</a>
<a href="#dup">dup</a>
<a href="#duphash">dup_hash</a>
<a href="#duparray">duparray</a>
<a href="#getconstant">getconstant</a>
<a href="#getglobal">getglobal</a>
<a href="#getlocalwc0">getlocal_wc_0</a>
<a href="#jump">jump</a>
<a href="#leave">leave</a>
<a href="#newarray">newarray</a>
<a href="#newhash">newhash</a>
<a href="#optand">opt_and</a>
<a href="#optaref">opt_aref</a>
<a href="#optdiv">opt_div</a>
<a href="#optemptyp">opt_empty_p</a>
<a href="#opteq">opt_eq</a>
<a href="#optgetinlinecache">opt_getinlinecache</a>
<a href="#optlength">opt_length</a>
<a href="#optminus">opt_minus</a>
<a href="#optmod">opt_mod</a>
<a href="#optnilp">opt_nil_p</a>
<a href="#optnot">opt_not</a>
<a href="#optor">opt_or</a>
<a href="#optplus">opt_plus</a>
<a href="#optsendwithoutblock">opt_send_without_block</a>
<a href="#optsetinlinecache">opt_setinlinecache</a>
<a href="#optstrfreeze">opt_str_freeze</a>
<a href="#optstruminus">opt_str_uminus</a>
<a href="#optsucc">opt_succ</a>
<a href="#pop">pop</a>
<a href="#putnil">putnil</a>
<a href="#putobject">putobject</a>
<a href="#putobjectint2fix0">putobject_int2fix_0</a>
<a href="#putobjectint2fix1">putobject_int2fix_1</a>
<a href="#putself">putself</a>
<a href="#putstring">putstring</a>
<a href="#setglobal">setglobal</a>
<a href="#setlocalwc0">setlocal_wc_0</a>
<a href="#swap">swap</a>


        </nav>
      </aside>
      <article>
        <h1 id="yarv-instructions">YARV Instructions</h1>

<p>Below is a list of the YARV instructions that this project has documented so far.</p>

<hr />

<h2 id="branchunless">branchunless</h2>

<h3 id="summary">Summary</h3>

<p><code>branchunless</code> has one argument, the jump index
and pops one value off the stack, the jump condition.</p>

<p>If the value popped off the stack is false,
<code>branchunless</code> jumps to the jump index and continues executing there.</p>

<h3 id="tracepoint">TracePoint</h3>

<p><code>branchunless</code> does not dispatch any events.</p>

<h3 id="usage">Usage</h3>

<pre><code class="language-ruby">if 2+3; puts 'foo'; end

== disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,22)&gt; (catch: FALSE)
0000 putobject                              2                         (   1)[Li]
0002 putobject                              3
0004 opt_plus                               &lt;calldata!mid:+, argc:1, ARGS_SIMPLE&gt;[CcCr]
0006 branchunless                           14
0008 putself
0009 putstring                              "hi"
0011 opt_send_without_block                 &lt;calldata!mid:puts, argc:1, FCALL|ARGS_SIMPLE&gt;
0013 leave
0014 putnil
0015 leave
</code></pre>

<hr />

<h2 id="concatarray">concatarray</h2>

<h3 id="summary-1">Summary</h3>

<p><code>concatarray</code> concatenates the two Arrays on top of the stack.</p>

<p>It coerces the two objects at the top of the stack into Arrays by calling
<code>to_a</code> if necessary, and makes sure to <code>dup</code> the first Array if it was
already an Array, to avoid mutating it when concatenating.</p>

<h3 id="tracepoint-1">TracePoint</h3>

<p><code>concatarray</code> can dispatch the <code>line</code> and <code>call</code> events.</p>

<h3 id="usage-1">Usage</h3>

<pre><code class="language-ruby">[1,*2]

# == disasm: #&lt;ISeq:&lt;main&gt;@-e:1 (1,0)-(1,6)&gt; (catch: FALSE)
# 0000 duparray                               [1]                       (   1)[Li]
# 0002 putobject                              2
# 0004 concatarray
# 0005 leave
</code></pre>

<hr />

<h2 id="definemethod">definemethod</h2>

<h3 id="summary-2">Summary</h3>

<p><code>definemethod</code> defines a method on the class of the current value of <code>self</code>.
It accepts two arguments. The first is the name of the method being defined.
The second is the instruction sequence representing the body of the method.</p>

<h3 id="tracepoint-2">TracePoint</h3>

<p><code>definemethod</code> does not dispatch any events.</p>

<h3 id="usage-2">Usage</h3>

<pre><code class="language-ruby">def value = "value"

# == disasm: #&lt;ISeq:&lt;main&gt;@-e:1 (1,0)-(1,19)&gt; (catch: FALSE)
# 0000 definemethod                           :value, value             (   1)[Li]
# 0003 putobject                              :value
# 0005 leave
#
# == disasm: #&lt;ISeq:value@-e:1 (1,0)-(1,19)&gt; (catch: FALSE)
# 0000 putstring                              "value"                   (   1)[Ca]
# 0002 leave                                  [Re]
</code></pre>

<hr />

<h2 id="dup">dup</h2>

<h3 id="summary-3">Summary</h3>

<p><code>dup</code> copies the top value of the stack and pushes it onto the stack.</p>

<h3 id="tracepoint-3">TracePoint</h3>

<p><code>dup</code> does not dispatch any events.</p>

<h3 id="usage-3">Usage</h3>

<pre><code class="language-ruby">$global = 5

# == disasm: #&lt;ISeq:&lt;main&gt;@-e:1 (1,0)-(1,11)&gt; (catch: FALSE)
# 0000 putobject                              5                         (   1)[Li]
# 0002 dup
# 0003 setglobal                              :$global
# 0005 leave
</code></pre>

<hr />

<h2 id="duphash">dup_hash</h2>

<h3 id="summary-4">Summary</h3>

<p><code>duphash</code> pushes a hash onto the stack</p>

<h3 id="tracepoint-4">TracePoint</h3>

<p><code>duphash</code> can dispatch the line event.</p>

<h3 id="usage-4">Usage</h3>

<pre><code class="language-ruby">{ a: 1 }

# == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,8)&gt; (catch: FALSE)
# 0000 duphash                                {:a=&gt;1}                   (   1)[Li]
# 0002 leave
</code></pre>

<hr />

<h2 id="duparray">duparray</h2>

<h3 id="summary-5">Summary</h3>

<p><code>duparray</code> copies a literal Array and pushes it onto the stack.</p>

<h3 id="tracepoint-5">TracePoint</h3>

<p><code>duparray</code> can dispatch the <code>line</code> event.</p>

<h3 id="usage-5">Usage</h3>

<pre><code class="language-ruby">[true]

# == disasm: #&lt;ISeq:&lt;main&gt;@-e:1 (1,0)-(1,6)&gt; (catch: FALSE)
# 0000 duparray                               [true]                    (   1)[Li]
# 0002 leave
</code></pre>

<hr />

<h2 id="getconstant">getconstant</h2>

<h3 id="summary-6">Summary</h3>

<p><code>getconstant</code> performs a constant lookup and pushes the value of the
constant onto the stack.</p>

<h3 id="tracepoint-6">TracePoint</h3>

<p><code>getconstant</code> does not dispatch any events.</p>

<h3 id="usage-6">Usage</h3>

<pre><code class="language-ruby">Constant

# == disasm: #&lt;ISeq:&lt;main&gt;@-e:1 (1,0)-(1,8)&gt; (catch: FALSE)
# 0000 opt_getinlinecache                     9, &lt;is:0&gt;                 (   1)[Li]
# 0003 putobject                              true
# 0005 getconstant                            :Constant
# 0007 opt_setinlinecache                     &lt;is:0&gt;
# 0009 leave
</code></pre>

<hr />

<h2 id="getglobal">getglobal</h2>

<h3 id="summary-7">Summary</h3>

<p><code>getglobal</code> pushes the value of a global variables onto the stack.</p>

<h3 id="tracepoint-7">TracePoint</h3>

<p><code>getglobal</code> does not dispatch any events.</p>

<h3 id="usage-7">Usage</h3>

<pre><code class="language-ruby">$$

# == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,2)&gt; (catch: FALSE)
# 0000 getglobal                              :$$                       (   1)[Li]
# 0002 leave
</code></pre>

<hr />

<h2 id="getlocalwc0">getlocal_wc_0</h2>

<h3 id="summary-8">Summary</h3>

<p><code>getlocal_WC_0</code> is a specialized version of the <code>getlocal</code> instruction. It
fetches the value of a local variable from the current frame determined by
the index given as its only argument.</p>

<h3 id="tracepoint-8">TracePoint</h3>

<p><code>getlocal_WC_0</code> does not dispatch any events.</p>

<h3 id="usage-8">Usage</h3>

<pre><code class="language-ruby">value = 5; value

# == disasm: #&lt;ISeq:&lt;main&gt;@-e:1 (1,0)-(1,16)&gt; (catch: FALSE)
# local table (size: 1, argc: 0 [opts: 0, rest: -1, post: 0, block: -1, kw: -1@-1, kwrest: -1])
# [ 1] value@0
# 0000 putobject                              5                         (   1)[Li]
# 0002 setlocal_WC_0                          value@0
# 0004 getlocal_WC_0                          value@0
# 0006 leave
</code></pre>

<hr />

<h2 id="jump">jump</h2>

<h3 id="summary-9">Summary</h3>

<p><code>jump</code> has one argument, the jump index, which it uses to set the next
instruction to execute.</p>

<h3 id="tracepoint-9">TracePoint</h3>

<p>There is no trace point for <code>jump</code>.</p>

<h3 id="usage-9">Usage</h3>

<pre><code class="language-ruby">y = 0; if y == 0 then puts '0' else puts '2' end

== disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,48)&gt; (catch: FALSE)
local table (size: 1, argc: 0 [opts: 0, rest: -1, post: 0, block: -1, kw: -1@-1, kwrest: -1])
[ 1] y@0
0000 putobject_INT2FIX_0_                                             (   1)[Li]
0001 setlocal_WC_0                          y@0
0003 getlocal_WC_0                          y@0
0005 putobject_INT2FIX_0_
0006 opt_eq                                 &lt;calldata!mid:==, argc:1, ARGS_SIMPLE&gt;[CcCr]
0008 branchunless                           20
0010 jump                                   12
0012 putself
0013 putstring                              "0"
0015 opt_send_without_block                 &lt;calldata!mid:puts, argc:1, FCALL|ARGS_SIMPLE&gt;
0017 jump                                   25
0019 pop
0020 putself
0021 putstring                              "2"
0023 opt_send_without_block                 &lt;calldata!mid:puts, argc:1, FCALL|ARGS_SIMPLE&gt;
0025 leave
</code></pre>

<hr />

<h2 id="leave">leave</h2>

<h3 id="summary-10">Summary</h3>

<p><code>leave</code> exits the current frame.</p>

<h3 id="tracepoint-10">TracePoint</h3>

<p><code>leave</code> does not dispatch any events.</p>

<h3 id="usage-10">Usage</h3>

<pre><code class="language-ruby">;;

# == disasm: #&lt;ISeq:&lt;main&gt;@-e:1 (1,0)-(1,2)&gt; (catch: FALSE)
# 0000 putnil
# 0001 leave
</code></pre>

<hr />

<h2 id="newarray">newarray</h2>

<h3 id="summary-11">Summary</h3>

<p><code>newarray</code> puts a new array initialized with <code>size</code> values from the stack.</p>

<h3 id="tracepoint-11">TracePoint</h3>

<p><code>newarray</code> dispatches a <code>line</code> event.</p>

<h3 id="usage-11">Usage</h3>

<pre><code class="language-ruby">["string"]

# == disasm: #&lt;ISeq:&lt;main&gt;@-e:1 (1,0)-(1,10)&gt; (catch: FALSE)
# 0000 putstring                              "string"                  (   1)[Li]
# 0002 newarray                               1
# 0004 leave
</code></pre>
<hr />

<h2 id="newhash">newhash</h2>

<h3 id="summary-12">Summary</h3>

<p><code>newhash</code> puts a new hash onto the stack, using <code>num</code> elements from the
stack. <code>num</code> needs to be even.</p>

<h3 id="tracepoint-12">TracePoint</h3>

<p><code>newhash</code> does not dispatch any events.</p>

<h3 id="usage-12">Usage</h3>

<pre><code class="language-ruby">def foo(key, value)
  { key =&gt; value }
end

# == disasm: #&lt;ISeq:foo@-e:1 (1,0)-(3,3)&gt; (catch: FALSE)
# local table (size: 2, argc: 2 [opts: 0, rest: -1, post: 0, block: -1, kw: -1@-1, kwrest: -1])
# [ 2] key@0&lt;Arg&gt; [ 1] value@1&lt;Arg&gt;
# 0000 getlocal_WC_0                          key@0                     (   2)[LiCa]
# 0002 getlocal_WC_0                          value@1
# 0004 newhash                                2
# 0006 leave                                                            (   3)[Re]
</code></pre>

<hr />

<h2 id="optand">opt_and</h2>

<h3 id="summary-13">Summary</h3>

<p><code>opt_and</code> is a specialization of the <code>opt_send_without_block</code> instruction
that occurs when the <code>&amp;</code> operator is used. In CRuby, there are fast paths
for if both operands are integers.</p>

<h3 id="tracepoint-13">TracePoint</h3>

<p><code>opt_and</code> can dispatch both the <code>c_call</code> and <code>c_return</code> events.</p>

<h3 id="usage-13">Usage</h3>

<pre><code class="language-ruby">2 &amp; 3

# == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,5)&gt; (catch: FALSE)
# 0000 putobject                              2                         (   1)[Li]
# 0002 putobject                              3
# 0004 opt_and                                &lt;calldata!mid:&amp;, argc:1, ARGS_SIMPLE&gt;[CcCr]
# 0006 leave
</code></pre>

<hr />

<h2 id="optaref">opt_aref</h2>

<h3 id="summary-14">Summary</h3>

<p><code>opt_aref</code> is a specialization of the <code>opt_send_without_block</code> instruction
that occurs when the <code>[]</code> operator is used. In CRuby, there are fast paths
if the receiver is an integer, array, or hash.</p>

<h3 id="tracepoint-14">TracePoint</h3>

<p><code>opt_aref</code> can dispatch both the <code>c_call</code> and <code>c_return</code> events.</p>

<h3 id="usage-14">Usage</h3>

<pre><code class="language-ruby">7[2]

# == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,5)&gt; (catch: FALSE)
# 0000 putobject                              7                         (   1)[Li]
# 0002 putobject                              2
# 0004 opt_aref                               &lt;calldata!mid:[], argc:1, ARGS_SIMPLE&gt;[CcCr]
# 0006 leave
</code></pre>

<hr />

<h2 id="optdiv">opt_div</h2>

<h3 id="summary-15">Summary</h3>

<p><code>opt_div</code> is a specialization of the <code>opt_send_without_block</code> instruction
that occurs when the <code>/</code> operator is used. In CRuby, there are fast paths
for if both operands are integers, or if both operands are floats.</p>

<h3 id="tracepoint-15">TracePoint</h3>

<p><code>opt_div</code> can dispatch both the <code>c_call</code> and <code>c_return</code> events.</p>

<h3 id="usage-15">Usage</h3>

<pre><code class="language-ruby">2 / 3

# == disasm: #&lt;ISeq:&lt;main&gt;@-e:1 (1,0)-(1,5)&gt; (catch: FALSE)
# 0000 putobject                              2                         (   1)[Li]
# 0002 putobject                              3
# 0004 opt_div                                &lt;calldata!mid:/, argc:1, ARGS_SIMPLE&gt;[CcCr]
# 0006 leave
</code></pre>

<hr />

<h2 id="optemptyp">opt_empty_p</h2>

<h3 id="summary-16">Summary</h3>

<p><code>opt_empty_p</code> is an optimization applied when the method <code>empty?</code> is called
on a String, Array or a Hash. This optimization can be applied because Ruby
knows how to calculate the length of these objects using internal C macros.</p>

<h3 id="tracepoint-16">TracePoint</h3>

<p><code>opt_empty_p</code> can dispatch <code>c_call</code> and <code>c_return</code> events.</p>

<h3 id="usage-16">Usage</h3>

<pre><code class="language-ruby">"".empty?

#== disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,9)&gt; (catch: FALSE)
#0000 putstring                              ""                        (   1)[Li]
#0002 opt_empty_p                            &lt;calldata!mid:empty?, argc:0, ARGS_SIMPLE&gt;[CcCr]
#0004 leave
</code></pre>

<hr />

<h2 id="opteq">opt_eq</h2>

<h3 id="summary-17">Summary</h3>

<p><code>opt_eq</code> is a specialization of the <code>opt_send_without_block</code> instruction
that occurs when the == operator is used. Fast paths exist within CRuby when
both operands are integers, floats, symbols or strings.</p>

<h3 id="tracepoint-17">TracePoint</h3>

<p><code>opt_eq</code> can dispatch both the <code>c_call</code> and <code>c_return</code> events.</p>

<h3 id="usage-17">Usage</h3>

<pre><code class="language-ruby">2 == 2

# == disasm: #&lt;ISeq:&lt;main&gt;@-e:1 (1,0)-(1,6)&gt; (catch: FALSE)
# 0000 putobject                              2                         (   1)[Li]
# 0002 putobject                              2
# 0004 opt_eq                                 &lt;calldata!mid:==, argc:1, ARGS_SIMPLE&gt;[CcCr]
# 0006 leave
</code></pre>

<hr />

<h2 id="optgetinlinecache">opt_getinlinecache</h2>

<h3 id="summary-18">Summary</h3>

<p><code>opt_getinlinecache</code> is a wrapper around a series of <code>getconstant</code>
instructions that allows skipping past them if the inline cache is currently
set.</p>

<h3 id="tracepoint-18">TracePoint</h3>

<p><code>opt_getinlinecache</code> does not dispatch any events.</p>

<h3 id="usage-18">Usage</h3>

<pre><code class="language-ruby">Constant

# == disasm: #&lt;ISeq:&lt;main&gt;@-e:1 (1,0)-(1,8)&gt; (catch: FALSE)
# 0000 opt_getinlinecache                     9, &lt;is:0&gt;                 (   1)[Li]
# 0003 putobject                              true
# 0005 getconstant                            :Constant
# 0007 opt_setinlinecache                     &lt;is:0&gt;
# 0009 leave
</code></pre>

<hr />

<h2 id="optlength">opt_length</h2>

<h3 id="summary-19">Summary</h3>

<p><code>opt_length</code> is a specialization of <code>opt_send_without_block</code>, when the
<code>length</code> method is called on a Ruby type with a known size. In CRuby there
are fast paths when the receiver is either a String, Hash or Array.</p>

<h3 id="tracepoint-19">TracePoint</h3>

<p><code>opt_length</code> can dispatch <code>c_call</code> and <code>c_return</code> events.</p>

<h3 id="usage-19">Usage</h3>

<pre><code class="language-ruby">"".length

#== disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,9)&gt; (catch: FALSE)
#0000 putstring                              ""                        (   1)[Li]
#0002 opt_length                             &lt;calldata!mid:length, argc:0, ARGS_SIMPLE&gt;[CcCr]
#0004 leave
</code></pre>

<hr />

<h2 id="optminus">opt_minus</h2>

<h3 id="summary-20">Summary</h3>

<p><code>opt_minus</code> is a specialization of the <code>opt_send_without_block</code> instruction
that occurs when the <code>-</code> operator is used. In CRuby, there are fast paths
for if both operands are integers or both operands are floats.</p>

<h3 id="tracepoint-20">TracePoint</h3>

<p><code>opt_minus</code> can dispatch both the <code>c_call</code> and <code>c_return</code> events.</p>

<h3 id="usage-20">Usage</h3>

<pre><code class="language-ruby">3 - 2

# == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,5)&gt; (catch: FALSE)
# 0000 putobject                              3                         (   1)[Li]
# 0002 putobject                              2
# 0004 opt_minus                              &lt;calldata!mid:-, argc:1, ARGS_SIMPLE&gt;[CcCr]
# 0006 leave
</code></pre>

<hr />

<h2 id="optmod">opt_mod</h2>

<h3 id="summary-21">Summary</h3>

<p><code>opt_mod</code> is a specialization of the <code>opt_send_without_block</code> instruction
that occurs when the <code>%</code> operator is used. In CRuby, there are fast paths
for if both operands are integers or both operands are floats.</p>

<h3 id="tracepoint-21">TracePoint</h3>

<p><code>opt_eq</code> can dispatch both the <code>c_call</code> and <code>c_return</code> events.</p>

<h3 id="usage-21">Usage</h3>

<pre><code class="language-ruby">4 % 2

#   == disasm: #&lt;ISeq:&lt;main&gt;@-e:1 (1,0)-(1,5)&gt; (catch: FALSE)
#   0000 putobject                              4                         (   1)[Li]
#   0002 putobject                              2
#   0004 opt_mod                                &lt;calldata!mid:%, argc:1, ARGS_SIMPLE&gt;[CcCr]
#   0006 leave
</code></pre>

<hr />

<h2 id="optnilp">opt_nil_p</h2>

<h3 id="summary-22">Summary</h3>

<p><code>opt_nil_p</code> is an optimization applied when the method <code>nil?</code> is called. It
returns true immediately when the receiver is <code>nil</code> and defers to the <code>nil?</code>
method in other cases</p>

<h3 id="tracepoint-22">TracePoint</h3>

<p><code>opt_nil_p</code> can dispatch <code>c_call</code> and <code>c_return</code> events.</p>

<h3 id="usage-22">Usage</h3>

<pre><code class="language-ruby">"".nil?

#== disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,9)&gt; (catch: FALSE)
#0000 putstring                              ""                        (   1)[Li]
#0002 opt_nil_p                              &lt;calldata!mid:nil?, argc:0, ARGS_SIMPLE&gt;[CcCr]
#0004 leave
</code></pre>

<hr />

<h2 id="optnot">opt_not</h2>

<h3 id="summary-23">Summary</h3>

<p><code>opt_not</code> negates the value on top of the stack.</p>

<h3 id="tracepoint-23">TracePoint</h3>

<p><code>opt_not</code> can dispatch both the <code>c_call</code> and <code>c_return</code> events.</p>

<h3 id="usage-23">Usage</h3>

<pre><code class="language-ruby">!true

# == disasm: #&lt;ISeq:&lt;main&gt;@-e:1 (1,0)-(1,5)&gt; (catch: FALSE)
# 0000 putobject                              true                      (   1)[Li]
# 0002 opt_not                                &lt;calldata!mid:!, argc:0, ARGS_SIMPLE&gt;[CcCr]
# 0004 leave
</code></pre>

<hr />

<h2 id="optor">opt_or</h2>

<h3 id="summary-24">Summary</h3>

<p><code>opt_or</code> is a specialization of the <code>opt_send_without_block</code> instruction
that occurs when the <code>|</code> operator is used. In CRuby, there are fast paths
for if both operands are integers.</p>

<h3 id="tracepoint-24">TracePoint</h3>

<p><code>opt_or</code> can dispatch both the <code>c_call</code> and <code>c_return</code> events.</p>

<h3 id="usage-24">Usage</h3>

<pre><code class="language-ruby">2 | 3

# == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,5)&gt; (catch: FALSE)
# 0000 putobject                              2                         (   1)[Li]
# 0002 putobject                              3
# 0004 opt_or                                 &lt;calldata!mid:|, argc:1, ARGS_SIMPLE&gt;[CcCr]
# 0006 leave
</code></pre>

<hr />

<h2 id="optplus">opt_plus</h2>

<h3 id="summary-25">Summary</h3>

<p><code>opt_plus</code> is a specialization of the <code>opt_send_without_block</code> instruction
that occurs when the <code>+</code> operator is used. In CRuby, there are fast paths
for if both operands are integers, floats, strings, or arrays.</p>

<h3 id="tracepoint-25">TracePoint</h3>

<p><code>opt_plus</code> can dispatch both the <code>c_call</code> and <code>c_return</code> events.</p>

<h3 id="usage-25">Usage</h3>

<pre><code class="language-ruby">2 + 3

# == disasm: #&lt;ISeq:&lt;main&gt;@-e:1 (1,0)-(1,5)&gt; (catch: FALSE)
# 0000 putobject                              2                         (   1)[Li]
# 0002 putobject                              3
# 0004 opt_plus                               &lt;calldata!mid:+, argc:1, ARGS_SIMPLE&gt;[CcCr]
# 0006 leave
</code></pre>

<hr />

<h2 id="optsendwithoutblock">opt_send_without_block</h2>

<h3 id="summary-26">Summary</h3>

<p><code>opt_send_without_block</code> is a specialization of the send instruction that
occurs when a method is being called without a block.</p>

<h3 id="tracepoint-26">TracePoint</h3>

<p><code>opt_send_without_block</code> does not dispatch any events.</p>

<h3 id="usage-26">Usage</h3>

<pre><code class="language-ruby">puts "Hello, world!"

# == disasm: #&lt;ISeq:&lt;main&gt;@-e:1 (1,0)-(1,20)&gt; (catch: FALSE)
# 0000 putself                                                          (   1)[Li]
# 0001 putstring                              "Hello, world!"
# 0003 opt_send_without_block                 &lt;calldata!mid:puts, argc:1, FCALL|ARGS_SIMPLE&gt;
# 0005 leave
</code></pre>

<hr />

<h2 id="optsetinlinecache">opt_setinlinecache</h2>

<h3 id="summary-27">Summary</h3>

<p><code>opt_setinlinecache</code> is the final instruction after a series of
<code>getconstant</code> instructions that populates the inline cache associated with
an <code>opt_getinlinecache</code> instruction.</p>

<h3 id="tracepoint-27">TracePoint</h3>

<p><code>opt_setinlinecache</code> does not dispatch any events.</p>

<h3 id="usage-27">Usage</h3>

<pre><code class="language-ruby">Constant

# == disasm: #&lt;ISeq:&lt;main&gt;@-e:1 (1,0)-(1,8)&gt; (catch: FALSE)
# 0000 opt_getinlinecache                     9, &lt;is:0&gt;                 (   1)[Li]
# 0003 putobject                              true
# 0005 getconstant                            :Constant
# 0007 opt_setinlinecache                     &lt;is:0&gt;
# 0009 leave
</code></pre>

<hr />

<h2 id="optstrfreeze">opt_str_freeze</h2>

<h3 id="summary-28">Summary</h3>

<p><code>opt_str_freeze</code> pushes a frozen known string value with no interpolation
onto the stack.</p>

<h3 id="tracepoint-28">TracePoint</h3>

<p><code>opt_str_freeze</code> does not dispatch any events.</p>

<h3 id="usage-28">Usage</h3>

<pre><code class="language-ruby">'hello'.freeze

# == disasm: #&lt;ISeq:&lt;main&gt;@-e:1 (1,0)-(1,14)&gt; (catch: FALSE)
# 0000 opt_str_freeze                         "hello", &lt;calldata!mid:freeze, argc:0, ARGS_SIMPLE&gt;(   1)[Li]
# 0003 leave
</code></pre>

<hr />

<h2 id="optstruminus">opt_str_uminus</h2>

<h3 id="summary-29">Summary</h3>

<p><code>opt_str_uminus</code> pushes a frozen known string value with no interpolation
onto the stack.</p>

<h3 id="tracepoint-29">TracePoint</h3>

<p><code>opt_str_uminus</code> does not dispatch any events.</p>

<h3 id="usage-29">Usage</h3>

<pre><code class="language-ruby">-"string"

# == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,6)&gt; (catch: FALSE)
# 0000 opt_str_uminus                         "string", &lt;calldata!mid:-@, argc:0, ARGS_SIMPLE&gt;(   1)[Li]
# 0003 leave
</code></pre>

<hr />

<h2 id="optsucc">opt_succ</h2>

<h3 id="summary-30">Summary</h3>

<p><code>opt_succ</code> is a specialization of the <code>opt_send_without_block</code> instruction
when the method being called is <code>succ</code>. Fast paths exist within CRuby when
the receiver is either a String or a Fixnum.</p>

<h3 id="tracepoint-30">TracePoint</h3>

<p><code>opt_succ</code> can dispatch <code>c_call</code> and <code>c_return</code> events.</p>

<h3 id="usage-30">Usage</h3>

<pre><code class="language-ruby">"".succ

#== disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,8)&gt; (catch: FALSE)
#0000 putstring                              "a"                       (   1)[Li]
#0002 opt_succ                               &lt;calldata!mid:succ, argc:0, ARGS_SIMPLE&gt;[CcCr]
#0004 leave
</code></pre>

<hr />

<h2 id="pop">pop</h2>

<h3 id="summary-31">Summary</h3>

<p><code>pop</code> pops the top value off the stack.</p>

<h3 id="tracepoint-31">TracePoint</h3>

<p><code>pop</code> does not dispatch any events.</p>

<h3 id="usage-31">Usage</h3>

<pre><code class="language-ruby">a ||= 2

# == disasm: #&lt;ISeq:&lt;main&gt;@-e:1 (1,0)-(1,7)&gt; (catch: FALSE)
# local table (size: 1, argc: 0 [opts: 0, rest: -1, post: 0, block: -1, kw: -1@-1, kwrest: -1])
# [ 1] a@0
# 0000 getlocal_WC_0                          a@0                       (   1)[Li]
# 0002 dup
# 0003 branchif                               11
# 0005 pop
# 0006 putobject                              2
# 0008 dup
# 0009 setlocal_WC_0                          a@0
# 0011 leave
</code></pre>

<hr />

<h2 id="putnil">putnil</h2>

<h3 id="summary-32">Summary</h3>

<p><code>putnil</code> pushes a global nil object onto the stack.</p>

<h3 id="tracepoint-32">TracePoint</h3>

<p><code>putnil</code> can dispatch the line event.</p>

<h3 id="usage-32">Usage</h3>

<pre><code class="language-ruby">nil

# == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,3)&gt; (catch: FALSE)
# 0000 putnil                                                           (   1)[Li]
# 0001 leave
</code></pre>

<hr />

<h2 id="putobject">putobject</h2>

<h3 id="summary-33">Summary</h3>

<p><code>putobject</code> pushes a known value onto the stack.</p>

<h3 id="tracepoint-33">TracePoint</h3>

<p><code>putobject</code> can dispatch the line event.</p>

<h3 id="usage-33">Usage</h3>

<pre><code class="language-ruby">5

# == disasm: #&lt;ISeq:&lt;main&gt;@-e:1 (1,0)-(1,1)&gt; (catch: FALSE)
# 0000 putobject                              5                         (   1)[Li]
# 0002 leave
</code></pre>

<hr />

<h2 id="putobjectint2fix0">putobject_int2fix_0</h2>

<h3 id="summary-34">Summary</h3>

<p><code>putobject_INT2FIX_0_</code> pushes 0 on the stack.
It is a specialized instruction resulting from the operand
unification optimization. It is the equivalent to <code>putobject 0</code>.</p>

<h3 id="tracepoint-34">TracePoint</h3>

<p><code>putobject</code> can dispatch the line event.</p>

<h3 id="usage-34">Usage</h3>

<pre><code class="language-ruby">0

# == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,1)&gt; (catch: FALSE)
# 0000 putobject_INT2FIX_0_                                             (   1)[Li]
# 0001 leave
</code></pre>

<hr />

<h2 id="putobjectint2fix1">putobject_int2fix_1</h2>

<h3 id="summary-35">Summary</h3>

<p><code>putobject_INT2FIX_1_</code> pushes 1 on the stack.
It is a specialized instruction resulting from the operand
unification optimization. It is the equivalent to <code>putobject 1</code>.</p>

<h3 id="tracepoint-35">TracePoint</h3>

<p><code>putobject</code> can dispatch the line event.</p>

<h3 id="usage-35">Usage</h3>

<pre><code class="language-ruby">1

# == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,1)&gt; (catch: FALSE)
# 0000 putobject_INT2FIX_1_                                             (   1)[Li]
# 0001 leave
</code></pre>

<hr />

<h2 id="putself">putself</h2>

<h3 id="summary-36">Summary</h3>

<p><code>putself</code> pushes the current value of self onto the stack.</p>

<h3 id="tracepoint-36">TracePoint</h3>

<p><code>putself</code> can dispatch the line event.</p>

<h3 id="usage-36">Usage</h3>

<pre><code class="language-ruby">puts "Hello, world!"

# == disasm: #&lt;ISeq:&lt;main&gt;@-e:1 (1,0)-(1,20)&gt; (catch: FALSE)
# 0000 putself                                                          (   1)[Li]
# 0001 putstring                              "Hello, world!"
# 0003 opt_send_without_block                 &lt;calldata!mid:puts, argc:1, FCALL|ARGS_SIMPLE&gt;
# 0005 leave
</code></pre>

<hr />

<h2 id="putstring">putstring</h2>

<h3 id="summary-37">Summary</h3>

<p><code>putstring</code> pushes a string literal onto the stack.</p>

<h3 id="tracepoint-37">TracePoint</h3>

<p><code>putstring</code> can dispatch the line event.</p>

<h3 id="usage-37">Usage</h3>

<pre><code class="language-ruby">"foo"

# == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,5)&gt; (catch: FALSE)
# 0000 putstring                              "foo"                     (   1)[Li]
# 0002 leave
</code></pre>

<hr />

<h2 id="setglobal">setglobal</h2>

<h3 id="summary-38">Summary</h3>

<p><code>setglobal</code> sets the value of a global variable.</p>

<h3 id="tracepoint-38">TracePoint</h3>

<p><code>setglobal</code> does not dispatch any events.</p>

<h3 id="usage-38">Usage</h3>

<pre><code class="language-ruby">$global = 5

# == disasm: #&lt;ISeq:&lt;main&gt;@-e:1 (1,0)-(1,11)&gt; (catch: FALSE)
# 0000 putobject                              5                         (   1)[Li]
# 0002 dup
# 0003 setglobal                              :$global
# 0005 leave
</code></pre>

<hr />

<h2 id="setlocalwc0">setlocal_wc_0</h2>

<h3 id="summary-39">Summary</h3>

<p><code>setlocal_WC_0</code> is a specialized version of the <code>setlocal</code> instruction. It
sets the value of a local variable on the current frame to the value at the
top of the stack as determined by the index given as its only argument.</p>

<h3 id="tracepoint-39">TracePoint</h3>

<p><code>setlocal_WC_0</code> does not dispatch any events.</p>

<h3 id="usage-39">Usage</h3>

<pre><code class="language-ruby">value = 5

# == disasm: #&lt;ISeq:&lt;main&gt;@-e:1 (1,0)-(1,9)&gt; (catch: FALSE)
# local table (size: 1, argc: 0 [opts: 0, rest: -1, post: 0, block: -1, kw: -1@-1, kwrest: -1])
# [ 1] value@0
# 0000 putobject                              5                         (   1)[Li]
# 0002 dup
# 0003 setlocal_WC_0                          value@0
# 0005 leave
</code></pre>

<hr />

<h2 id="swap">swap</h2>

<h3 id="summary-40">Summary</h3>

<p><code>swap</code> swaps the top two elements in the stack.</p>

<h3 id="tracepoint-40">TracePoint</h3>

<p><code>swap</code> does not dispatch any events.</p>

<h3 id="usage-40">Usage</h3>

<pre><code class="language-ruby">!!defined?([[]])

# == disasm: #&lt;ISeq:&lt;main&gt;@-e:1 (1,0)-(1,16)&gt; (catch: TRUE)
# == catch table
# | catch type: rescue st: 0001 ed: 0003 sp: 0000 cont: 0005
# | == disasm: #&lt;ISeq:defined guard in &lt;main&gt;@-e:0 (0,0)-(-1,-1)&gt; (catch: FALSE)
# | local table (size: 1, argc: 0 [opts: 0, rest: -1, post: 0, block: -1, kw: -1@-1, kwrest: -1])
# | [ 1] "\#$!"@0
# | 0000 putnil
# | 0001 leave
# |------------------------------------------------------------------------
# 0000 putnil                                                           (   1)[Li]
# 0001 putobject                    "expression"
# 0003 swap
# 0004 pop
# 0005 opt_not                      &lt;callinfo!mid:!, argc:0, ARGS_SIMPLE&gt;, &lt;callcache&gt;
# 0008 opt_not                      &lt;callinfo!mid:!, argc:0, ARGS_SIMPLE&gt;, &lt;callcache&gt;
# 0011 leave
</code></pre>


      </article>
    </main>
  </body>
</html>
