<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="initial-scale=1, maximum-scale=5">
    <title>YARV</title>
  </head>
  <body>
    <h1 id="yarv-instructions">YARV Instructions</h1>

<p>Below is a list of the YARV instructions that this project has documented so far.</p>

<ul>
  <li><a href="#branchunless">branchunless</a></li>
  <li><a href="#definemethod">definemethod</a></li>
  <li><a href="#dup">dup</a></li>
  <li><a href="#getconstant">getconstant</a></li>
  <li><a href="#getglobal">getglobal</a></li>
  <li><a href="#getlocalwc0">getlocal_wc_0</a></li>
  <li><a href="#leave">leave</a></li>
  <li><a href="#optand">opt_and</a></li>
  <li><a href="#optaref">opt_aref</a></li>
  <li><a href="#optdiv">opt_div</a></li>
  <li><a href="#optemptyp">opt_empty_p</a></li>
  <li><a href="#optgetinlinecache">opt_getinlinecache</a></li>
  <li><a href="#optlength">opt_length</a></li>
  <li><a href="#optminus">opt_minus</a></li>
  <li><a href="#optnilp">opt_nil_p</a></li>
  <li><a href="#optor">opt_or</a></li>
  <li><a href="#optplus">opt_plus</a></li>
  <li><a href="#optsendwithoutblock">opt_send_without_block</a></li>
  <li><a href="#optsetinlinecache">opt_setinlinecache</a></li>
  <li><a href="#optstruminus">opt_str_uminus</a></li>
  <li><a href="#optsucc">opt_succ</a></li>
  <li><a href="#pop">pop</a></li>
  <li><a href="#putobject">putobject</a></li>
  <li><a href="#putobjectint2fix0">putobject_int2fix_0</a></li>
  <li><a href="#putobjectint2fix1">putobject_int2fix_1</a></li>
  <li><a href="#putself">putself</a></li>
  <li><a href="#putstring">putstring</a></li>
  <li><a href="#setglobal">setglobal</a></li>
  <li><a href="#setlocalwc0">setlocal_wc_0</a></li>
</ul>

<h2 id="branchunless">branchunless</h2>

<h3 id="summary">Summary</h3>

<p><code>branchunless</code> has one argument, the jump index
and pops one value off the stack, the jump condition.</p>

<p>If the value popped off the stack is false,
<code>branchunless</code> jumps to the jump index and continues executing there.</p>

<h3 id="tracepoint">TracePoint</h3>

<p><code>branchunless</code> does not dispatch any events.</p>

<h3 id="usage">Usage</h3>

<pre><code class="language-ruby">if 2+3; puts 'foo'; end

== disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,22)&gt; (catch: FALSE)
0000 putobject                              2                         (   1)[Li]
0002 putobject                              3
0004 opt_plus                               &lt;calldata!mid:+, argc:1, ARGS_SIMPLE&gt;[CcCr]
0006 branchunless                           14
0008 putself
0009 putstring                              "hi"
0011 opt_send_without_block                 &lt;calldata!mid:puts, argc:1, FCALL|ARGS_SIMPLE&gt;
0013 leave
0014 putnil
0015 leave
</code></pre>

<h2 id="definemethod">definemethod</h2>

<h3 id="summary-1">Summary</h3>

<p><code>definemethod</code> defines a method on the class of the current value of <code>self</code>.
It accepts two arguments. The first is the name of the method being defined.
The second is the instruction sequence representing the body of the method.</p>

<h3 id="tracepoint-1">TracePoint</h3>

<p><code>definemethod</code> does not dispatch any events.</p>

<h3 id="usage-1">Usage</h3>

<pre><code class="language-ruby">def value = "value"

# == disasm: #&lt;ISeq:&lt;main&gt;@-e:1 (1,0)-(1,19)&gt; (catch: FALSE)
# 0000 definemethod                           :value, value             (   1)[Li]
# 0003 putobject                              :value
# 0005 leave
#
# == disasm: #&lt;ISeq:value@-e:1 (1,0)-(1,19)&gt; (catch: FALSE)
# 0000 putstring                              "value"                   (   1)[Ca]
# 0002 leave                                  [Re]
</code></pre>

<h2 id="dup">dup</h2>

<h3 id="summary-2">Summary</h3>

<p><code>dup</code> copies the top value of the stack and pushes it onto the stack.</p>

<h3 id="tracepoint-2">TracePoint</h3>

<p><code>dup</code> does not dispatch any events.</p>

<h3 id="usage-2">Usage</h3>

<pre><code class="language-ruby">$global = 5

# == disasm: #&lt;ISeq:&lt;main&gt;@-e:1 (1,0)-(1,11)&gt; (catch: FALSE)
# 0000 putobject                              5                         (   1)[Li]
# 0002 dup
# 0003 setglobal                              :$global
# 0005 leave
</code></pre>

<h2 id="getconstant">getconstant</h2>

<h3 id="summary-3">Summary</h3>

<p><code>getconstant</code> performs a constant lookup and pushes the value of the
constant onto the stack.</p>

<h3 id="tracepoint-3">TracePoint</h3>

<p><code>getconstant</code> does not dispatch any events.</p>

<h3 id="usage-3">Usage</h3>

<pre><code class="language-ruby">Constant

# == disasm: #&lt;ISeq:&lt;main&gt;@-e:1 (1,0)-(1,8)&gt; (catch: FALSE)
# 0000 opt_getinlinecache                     9, &lt;is:0&gt;                 (   1)[Li]
# 0003 putobject                              true
# 0005 getconstant                            :Constant
# 0007 opt_setinlinecache                     &lt;is:0&gt;
# 0009 leave
</code></pre>

<h2 id="getglobal">getglobal</h2>

<h3 id="summary-4">Summary</h3>

<p><code>getglobal</code> pushes the value of a global variables onto the stack.</p>

<h3 id="tracepoint-4">TracePoint</h3>

<p><code>getglobal</code> does not dispatch any events.</p>

<h3 id="usage-4">Usage</h3>

<pre><code class="language-ruby">$$

# == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,2)&gt; (catch: FALSE)
# 0000 getglobal                              :$$                       (   1)[Li]
# 0002 leave
</code></pre>

<h2 id="getlocalwc0">getlocal_wc_0</h2>

<h3 id="summary-5">Summary</h3>

<p><code>getlocal_WC_0</code> is a specialized version of the <code>getlocal</code> instruction. It
fetches the value of a local variable from the current frame determined by
the index given as its only argument.</p>

<h3 id="tracepoint-5">TracePoint</h3>

<p><code>getlocal_WC_0</code> does not dispatch any events.</p>

<h3 id="usage-5">Usage</h3>

<pre><code class="language-ruby">value = 5; value

# == disasm: #&lt;ISeq:&lt;main&gt;@-e:1 (1,0)-(1,16)&gt; (catch: FALSE)
# local table (size: 1, argc: 0 [opts: 0, rest: -1, post: 0, block: -1, kw: -1@-1, kwrest: -1])
# [ 1] value@0
# 0000 putobject                              5                         (   1)[Li]
# 0002 setlocal_WC_0                          value@0
# 0004 getlocal_WC_0                          value@0
# 0006 leave

## leave

### Summary

`leave` exits the current frame.

### TracePoint

`leave` does not dispatch any events.

### Usage

~~~ruby
;;

# == disasm: #&lt;ISeq:&lt;main&gt;@-e:1 (1,0)-(1,2)&gt; (catch: FALSE)
# 0000 putnil
# 0001 leave
</code></pre>

<h2 id="optand">opt_and</h2>

<h3 id="summary-6">Summary</h3>

<p><code>opt_and</code> is a specialization of the <code>opt_send_without_block</code> instruction
that occurs when the <code>&amp;</code> operator is used. In CRuby, there are fast paths
for if both operands are integers.</p>

<h3 id="tracepoint-6">TracePoint</h3>

<p><code>opt_and</code> can dispatch both the <code>c_call</code> and <code>c_return</code> events.</p>

<h3 id="usage-6">Usage</h3>

<pre><code class="language-ruby">2 &amp; 3

# == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,5)&gt; (catch: FALSE)                                      │~
# 0000 putobject                              2                         (   1)[Li]                           │~
# 0002 putobject                              3                                                              │~
# 0004 opt_and                                &lt;calldata!mid:&amp;, argc:1, ARGS_SIMPLE&gt;[CcCr]                    │~
# 0006 leave
</code></pre>

<h2 id="optaref">opt_aref</h2>

<h3 id="summary-7">Summary</h3>

<p><code>opt_aref</code> is a specialization of the <code>opt_send_without_block</code> instruction
that occurs when the <code>[]</code> operator is used. In CRuby, there are fast paths
if the receiver is an integer, array, or hash.</p>

<h3 id="tracepoint-7">TracePoint</h3>

<p><code>opt_aref</code> can dispatch both the <code>c_call</code> and <code>c_return</code> events.</p>

<h3 id="usage-7">Usage</h3>

<pre><code class="language-ruby">7[2]

# == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,5)&gt; (catch: FALSE)                                      │~
# 0000 putobject                              7                         (   1)[Li]                           │~
# 0002 putobject                              2                                                              │~
# 0004 opt_aref                               &lt;calldata!mid:[], argc:1, ARGS_SIMPLE&gt;[CcCr]                    │~
# 0006 leave
</code></pre>

<h2 id="optdiv">opt_div</h2>

<h3 id="summary-8">Summary</h3>

<p><code>opt_div</code> is a specialization of the <code>opt_send_without_block</code> instruction
that occurs when the <code>/</code> operator is used. In CRuby, there are fast paths
for if both operands are integers, or if both operands are floats.</p>

<h3 id="tracepoint-8">TracePoint</h3>

<p><code>opt_div</code> can dispatch both the <code>c_call</code> and <code>c_return</code> events.</p>

<h3 id="usage-8">Usage</h3>

<pre><code class="language-ruby">2 / 3

# == disasm: #&lt;ISeq:&lt;main&gt;@-e:1 (1,0)-(1,5)&gt; (catch: FALSE)
# 0000 putobject                              2                         (   1)[Li]
# 0002 putobject                              3
# 0004 opt_div                                &lt;calldata!mid:/, argc:1, ARGS_SIMPLE&gt;[CcCr]
# 0006 leave
</code></pre>

<h2 id="optemptyp">opt_empty_p</h2>

<h3 id="summary-9">Summary</h3>

<p><code>opt_empty_p</code> is an optimization applied when the method <code>empty?</code> is called
on a String, Array or a Hash. This optimization can be applied because Ruby
knows how to calculate the length of these objects using internal C macros.</p>

<h3 id="tracepoint-9">TracePoint</h3>

<p><code>opt_empty_p</code> can dispatch <code>c_call</code> and <code>c_return</code> events.</p>

<h3 id="usage-9">Usage</h3>

<pre><code class="language-ruby">"".empty?

#== disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,9)&gt; (catch: FALSE)
#0000 putstring                              ""                        (   1)[Li]
#0002 opt_empty_p                            &lt;calldata!mid:empty?, argc:0, ARGS_SIMPLE&gt;[CcCr]
#0004 leave
</code></pre>

<h2 id="optgetinlinecache">opt_getinlinecache</h2>

<h3 id="summary-10">Summary</h3>

<p><code>opt_getinlinecache</code> is a wrapper around a series of <code>getconstant</code>
instructions that allows skipping past them if the inline cache is currently
set.</p>

<h3 id="tracepoint-10">TracePoint</h3>

<p><code>opt_getinlinecache</code> does not dispatch any events.</p>

<h3 id="usage-10">Usage</h3>

<pre><code class="language-ruby">Constant

# == disasm: #&lt;ISeq:&lt;main&gt;@-e:1 (1,0)-(1,8)&gt; (catch: FALSE)
# 0000 opt_getinlinecache                     9, &lt;is:0&gt;                 (   1)[Li]
# 0003 putobject                              true
# 0005 getconstant                            :Constant
# 0007 opt_setinlinecache                     &lt;is:0&gt;
# 0009 leave
</code></pre>

<h2 id="optlength">opt_length</h2>

<h3 id="summary-11">Summary</h3>

<p><code>opt_length</code> is a specialization of <code>opt_send_without_block</code>, when the
<code>length</code> method is called on a Ruby type with a known size. In CRuby there
are fast paths when the receiver is either a String, Hash or Array.</p>

<h3 id="tracepoint-11">TracePoint</h3>

<p><code>opt_length</code> can dispatch <code>c_call</code> and <code>c_return</code> events.</p>

<h3 id="usage-11">Usage</h3>

<pre><code class="language-ruby">"".length

#== disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,9)&gt; (catch: FALSE)
#0000 putstring                              ""                        (   1)[Li]
#0002 opt_length                             &lt;calldata!mid:length, argc:0, ARGS_SIMPLE&gt;[CcCr]
#0004 leave
</code></pre>

<h2 id="optminus">opt_minus</h2>

<h3 id="summary-12">Summary</h3>

<p><code>opt_minus</code> is a specialization of the <code>opt_send_without_block</code> instruction
that occurs when the <code>-</code> operator is used. In CRuby, there are fast paths
for if both operands are integers or both operands are floats.</p>

<h3 id="tracepoint-12">TracePoint</h3>

<p><code>opt_minus</code> can dispatch both the <code>c_call</code> and <code>c_return</code> events.</p>

<h3 id="usage-12">Usage</h3>

<pre><code class="language-ruby">3 - 2

# == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,5)&gt; (catch: FALSE)
# 0000 putobject                              3                         (   1)[Li]
# 0002 putobject                              2
# 0004 opt_minus                              &lt;calldata!mid:-, argc:1, ARGS_SIMPLE&gt;[CcCr]
# 0006 leave
</code></pre>

<h2 id="optnilp">opt_nil_p</h2>

<h3 id="summary-13">Summary</h3>

<p><code>opt_nil_p</code> is an optimization applied when the method <code>nil?</code> is called. It
returns true immediately when the receiver is <code>nil</code> and defers to the <code>nil?</code>
method in other cases</p>

<h3 id="tracepoint-13">TracePoint</h3>

<p><code>opt_nil_p</code> can dispatch <code>c_call</code> and <code>c_return</code> events.</p>

<h3 id="usage-13">Usage</h3>

<pre><code class="language-ruby">"".nil?

#== disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,9)&gt; (catch: FALSE)
#0000 putstring                              ""                        (   1)[Li]
#0002 opt_nil_p                              &lt;calldata!mid:nil?, argc:0, ARGS_SIMPLE&gt;[CcCr]
#0004 leave
</code></pre>

<h2 id="optor">opt_or</h2>

<h3 id="summary-14">Summary</h3>

<p><code>opt_or</code> is a specialization of the <code>opt_send_without_block</code> instruction
that occurs when the <code>|</code> operator is used. In CRuby, there are fast paths
for if both operands are integers.</p>

<h3 id="tracepoint-14">TracePoint</h3>

<p><code>opt_or</code> can dispatch both the <code>c_call</code> and <code>c_return</code> events.</p>

<h3 id="usage-14">Usage</h3>

<pre><code class="language-ruby">2 | 3

# == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,5)&gt; (catch: FALSE)
# 0000 putobject                              2                         (   1)[Li]
# 0002 putobject                              3
# 0004 opt_or                                 &lt;calldata!mid:|, argc:1, ARGS_SIMPLE&gt;[CcCr]
# 0006 leave
</code></pre>

<h2 id="optplus">opt_plus</h2>

<h3 id="summary-15">Summary</h3>

<p><code>opt_plus</code> is a specialization of the <code>opt_send_without_block</code> instruction
that occurs when the <code>+</code> operator is used. In CRuby, there are fast paths
for if both operands are integers, floats, strings, or arrays.</p>

<h3 id="tracepoint-15">TracePoint</h3>

<p><code>opt_plus</code> can dispatch both the <code>c_call</code> and <code>c_return</code> events.</p>

<h3 id="usage-15">Usage</h3>

<pre><code class="language-ruby">2 + 3

# == disasm: #&lt;ISeq:&lt;main&gt;@-e:1 (1,0)-(1,5)&gt; (catch: FALSE)
# 0000 putobject                              2                         (   1)[Li]
# 0002 putobject                              3
# 0004 opt_plus                               &lt;calldata!mid:+, argc:1, ARGS_SIMPLE&gt;[CcCr]
# 0006 leave
</code></pre>

<h2 id="optsendwithoutblock">opt_send_without_block</h2>

<h3 id="summary-16">Summary</h3>

<p><code>opt_send_without_block</code> is a specialization of the send instruction that
occurs when a method is being called without a block.</p>

<h3 id="tracepoint-16">TracePoint</h3>

<p><code>opt_send_without_block</code> does not dispatch any events.</p>

<h3 id="usage-16">Usage</h3>

<pre><code class="language-ruby">puts "Hello, world!"

# == disasm: #&lt;ISeq:&lt;main&gt;@-e:1 (1,0)-(1,20)&gt; (catch: FALSE)
# 0000 putself                                                          (   1)[Li]
# 0001 putstring                              "Hello, world!"
# 0003 opt_send_without_block                 &lt;calldata!mid:puts, argc:1, FCALL|ARGS_SIMPLE&gt;
# 0005 leave
</code></pre>

<h2 id="optsetinlinecache">opt_setinlinecache</h2>

<h3 id="summary-17">Summary</h3>

<p><code>opt_setinlinecache</code> is the final instruction after a series of
<code>getconstant</code> instructions that populates the inline cache associated with
an <code>opt_getinlinecache</code> instruction.</p>

<h3 id="tracepoint-17">TracePoint</h3>

<p><code>opt_setinlinecache</code> does not dispatch any events.</p>

<h3 id="usage-17">Usage</h3>

<pre><code class="language-ruby">Constant

# == disasm: #&lt;ISeq:&lt;main&gt;@-e:1 (1,0)-(1,8)&gt; (catch: FALSE)
# 0000 opt_getinlinecache                     9, &lt;is:0&gt;                 (   1)[Li]
# 0003 putobject                              true
# 0005 getconstant                            :Constant
# 0007 opt_setinlinecache                     &lt;is:0&gt;
# 0009 leave
</code></pre>

<h2 id="optstruminus">opt_str_uminus</h2>

<h3 id="summary-18">Summary</h3>

<p><code>opt_str_uminus</code> pushes a frozen known string value with no interpolation
onto the stack.</p>

<h3 id="tracepoint-18">TracePoint</h3>

<p><code>opt_str_uminus</code> does not dispatch any events.</p>

<h3 id="usage-18">Usage</h3>

<pre><code class="language-ruby">-"string"

# == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,6)&gt; (catch: FALSE)
# 0000 opt_str_uminus                         "string", &lt;calldata!mid:-@, argc:0, ARGS_SIMPLE&gt;(   1)[Li]
# 0003 leave
</code></pre>

<h2 id="optsucc">opt_succ</h2>

<h3 id="summary-19">Summary</h3>

<p><code>opt_succ</code> is a specialization of the <code>opt_send_without_block</code> instruction
when the method being called is <code>succ</code>. Fast paths exist within CRuby when
the receiver is either a String or a Fixnum.</p>

<h3 id="tracepoint-19">TracePoint</h3>

<p><code>opt_succ</code> can dispatch <code>c_call</code> and <code>c_return</code> events.</p>

<h3 id="usage-19">Usage</h3>

<pre><code class="language-ruby">"".succ

#== disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,8)&gt; (catch: FALSE)
#0000 putstring                              "a"                       (   1)[Li]
#0002 opt_succ                               &lt;calldata!mid:succ, argc:0, ARGS_SIMPLE&gt;[CcCr]
#0004 leave
</code></pre>

<h2 id="pop">pop</h2>

<h3 id="summary-20">Summary</h3>

<p><code>pop</code> pops the top value off the stack.</p>

<h3 id="tracepoint-20">TracePoint</h3>

<p><code>pop</code> does not dispatch any events.</p>

<h3 id="usage-20">Usage</h3>

<pre><code class="language-ruby">a ||= 2

# == disasm: #&lt;ISeq:&lt;main&gt;@-e:1 (1,0)-(1,7)&gt; (catch: FALSE)
# local table (size: 1, argc: 0 [opts: 0, rest: -1, post: 0, block: -1, kw: -1@-1, kwrest: -1])
# [ 1] a@0
# 0000 getlocal_WC_0                          a@0                       (   1)[Li]
# 0002 dup
# 0003 branchif                               11
# 0005 pop
# 0006 putobject                              2
# 0008 dup
# 0009 setlocal_WC_0                          a@0
# 0011 leave
</code></pre>

<h2 id="putobject">putobject</h2>

<h3 id="summary-21">Summary</h3>

<p><code>putobject</code> pushes a known value onto the stack.</p>

<h3 id="tracepoint-21">TracePoint</h3>

<p><code>putobject</code> can dispatch the line event.</p>

<h3 id="usage-21">Usage</h3>

<pre><code class="language-ruby">5

# == disasm: #&lt;ISeq:&lt;main&gt;@-e:1 (1,0)-(1,1)&gt; (catch: FALSE)
# 0000 putobject                              5                         (   1)[Li]
# 0002 leave
</code></pre>

<h2 id="putobjectint2fix0">putobject_int2fix_0</h2>

<h3 id="summary-22">Summary</h3>

<p><code>putobject_INT2FIX_0_</code> pushes 0 on the stack.
It is a specialized instruction resulting from the operand
unification optimization. It is the equivalent to <code>putobject 0</code>.</p>

<h3 id="tracepoint-22">TracePoint</h3>

<p><code>putobject</code> can dispatch the line event.</p>

<h3 id="usage-22">Usage</h3>

<pre><code class="language-ruby">0

# == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,1)&gt; (catch: FALSE)
# 0000 putobject_INT2FIX_0_                                             (   1)[Li]
# 0001 leave
</code></pre>

<h2 id="putobjectint2fix1">putobject_int2fix_1</h2>

<h3 id="summary-23">Summary</h3>

<p><code>putobject_INT2FIX_1_</code> pushes 1 on the stack.
It is a specialized instruction resulting from the operand
unification optimization. It is the equivalent to <code>putobject 1</code>.</p>

<h3 id="tracepoint-23">TracePoint</h3>

<p><code>putobject</code> can dispatch the line event.</p>

<h3 id="usage-23">Usage</h3>

<pre><code class="language-ruby">1

# == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,1)&gt; (catch: FALSE)
# 0000 putobject_INT2FIX_1_                                             (   1)[Li]
# 0001 leave
</code></pre>

<h2 id="putself">putself</h2>

<h3 id="summary-24">Summary</h3>

<p><code>putself</code> pushes the current value of self onto the stack.</p>

<h3 id="tracepoint-24">TracePoint</h3>

<p><code>putself</code> can dispatch the line event.</p>

<h3 id="usage-24">Usage</h3>

<pre><code class="language-ruby">puts "Hello, world!"

# == disasm: #&lt;ISeq:&lt;main&gt;@-e:1 (1,0)-(1,20)&gt; (catch: FALSE)
# 0000 putself                                                          (   1)[Li]
# 0001 putstring                              "Hello, world!"
# 0003 opt_send_without_block                 &lt;calldata!mid:puts, argc:1, FCALL|ARGS_SIMPLE&gt;
# 0005 leave
</code></pre>

<h2 id="putstring">putstring</h2>

<h3 id="summary-25">Summary</h3>

<p><code>putstring</code> pushes a string literal onto the stack.</p>

<h3 id="tracepoint-25">TracePoint</h3>

<p><code>putstring</code> can dispatch the line event.</p>

<h3 id="usage-25">Usage</h3>

<pre><code class="language-ruby">"foo"

# == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,5)&gt; (catch: FALSE)
# 0000 putstring                              "foo"                     (   1)[Li]
# 0002 leave
</code></pre>

<h2 id="setglobal">setglobal</h2>

<h3 id="summary-26">Summary</h3>

<p><code>setglobal</code> sets the value of a global variable.</p>

<h3 id="tracepoint-26">TracePoint</h3>

<p><code>setglobal</code> does not dispatch any events.</p>

<h3 id="usage-26">Usage</h3>

<pre><code class="language-ruby">$global = 5

# == disasm: #&lt;ISeq:&lt;main&gt;@-e:1 (1,0)-(1,11)&gt; (catch: FALSE)
# 0000 putobject                              5                         (   1)[Li]
# 0002 dup
# 0003 setglobal                              :$global
# 0005 leave
</code></pre>

<h2 id="setlocalwc0">setlocal_wc_0</h2>

<h3 id="summary-27">Summary</h3>

<p><code>setlocal_WC_0</code> is a specialized version of the <code>setlocal</code> instruction. It
sets the value of a local variable on the current frame to the value at the
top of the stack as determined by the index given as its only argument.</p>

<h3 id="tracepoint-27">TracePoint</h3>

<p><code>setlocal_WC_0</code> does not dispatch any events.</p>

<h3 id="usage-27">Usage</h3>

<pre><code class="language-ruby">value = 5

# == disasm: #&lt;ISeq:&lt;main&gt;@-e:1 (1,0)-(1,9)&gt; (catch: FALSE)
# local table (size: 1, argc: 0 [opts: 0, rest: -1, post: 0, block: -1, kw: -1@-1, kwrest: -1])
# [ 1] value@0
# 0000 putobject                              5                         (   1)[Li]
# 0002 dup
# 0003 setlocal_WC_0                          value@0
# 0005 leave
</code></pre>


  </body>
</html>
